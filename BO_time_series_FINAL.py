#!/usr/bin/env python

#%matplotlib inline
import numpy as np
import pickle as pickle
import time
from forcebalance.molecule import Molecule
import argparse

from BOTS_scanner_class_FINAL import BOTS_scanner

# record program start time
t0 = time.time()

"""
four necessary files:
    1. bond order list -> default name "bond_order.list"
        format:
              128
            frame 0 bond order list
                0     0    4.313  Fe  Fe
                0     1    0.204  Fe  Fe
                0     2    0.442  Fe  Fe
                0     3    0.508  Fe   C
                0     4    0.882  Fe   C
                0     5    0.874  Fe   C
                0     6    0.023  Fe   O
                0     7    0.076  Fe   O
                0     8    0.072  Fe   O
                0     9    0.043  Fe   C
                0    10    0.031  Fe   C
                0    11    0.027  Fe   C
                0    12    0.011  Fe   O
                0    13    0.030  Fe   O
                0    14    0.030  Fe   O
                0    15    0.788  Fe   C
                ...
              127
            frame 1 bond order list
                0     0    4.302  Fe  Fe
                ...
                
    2. energy minimized (geometry optimized) bond order list -> default name "opt_bond_order.list"
        format (this was aggregated from several separate optimizations and the correct frame numbers are not reflected by default):
              185
            frame 0 bond order list
                0     0    4.628  Fe  Fe
                0     1    0.400  Fe  Fe
                0     2    0.549  Fe  Fe
                0     3    0.496  Fe   C
                0     4    0.831  Fe   C
                0     5    0.842  Fe   C
                0     6    0.073  Fe   O
                0     7    0.110  Fe   O
                0     8    0.101  Fe   O
                0     9    0.091  Fe   C
                0    10    0.017  Fe   C
                0    11    0.028  Fe   C
                0    12    0.017  Fe   O
                0    13    0.020  Fe   O
                0    14    0.023  Fe   O
                0    15    0.720  Fe   C
                0    16    0.046  Fe   C
                ...
              185
            frame 0 bond order list
                0     0    4.627  Fe  Fe        
                ...
                
    3. ab initio molecular dynamics trajectory coordinates -> default name "coors.xyz"
        format (traditional xyz format):
            21
            frame 0   xyz file generated by terachem
              Fe       1.3221345947   -0.7280743911    0.0046954764
              Fe       0.0069389870    1.2114131577    0.0029265347
              Fe      -1.2752878525   -0.9143219978   -0.0029358512
               C       1.9966087785    1.1021369066   -0.0004091655
               C       2.4367875134   -1.1969453745    1.3100753416
               C       2.4427509933   -1.1944041385   -1.3031923850
               O       2.9460983229    1.8273895717   -0.0062736946
               O       3.1463485012   -1.5066038410    2.1989919439
               O       3.1391214153   -1.4927776428   -2.2061891898
               C      -1.8199911245    1.0476089573   -0.0068456356
               C      -0.0195795726    2.4385877636    1.2714405264
               C      -0.0127293152    2.4513487319   -1.2810162305
               O      -2.8951725351    1.5589816947    0.0088465396
               O      -0.0198189918    3.2336830668    2.1515950096
               O      -0.0080629906    3.2105143476   -2.1466885345
               C       0.2758863685   -2.1482396166   -0.0052630911
               C      -2.4405446012   -1.1197721024    1.3199638980
               C      -2.4521188659   -1.1139892657   -1.3381727928
               O      -0.4072830311   -3.1434248000    0.0070642062
               O      -3.1857114759   -1.2415089410    2.2240224796
               O      -3.1969186379   -1.2460873624   -2.2226575031
            21
            frame 1   xyz file generated by terachem
              Fe       1.3231716314   -0.7277565888    0.0092869631
              
    4. reference reactions clustering time series -> default name "timeseries_1.0.data"
        format (homemade file which is a pickled list containing assigned cluster indices by time step):
            [2 2 2 ... 9 9 9]
"""
   
def main():
    # create arguments 
    parser = argparse.ArgumentParser()
    parser.add_argument("-c", "--coordinates", default='coors.xyz', help='MD_coordinates')
    parser.add_argument("-b", "--raw_bond_order_list", default='bond_order.list', help='raw, unoptimized bond order information')
    parser.add_argument("-o", "--opt_bond_order_list", default='opt_bond_order.list', help='bond order information from the optimized trajectory frames')
    parser.add_argument("-r", "--reference_data", default='timeseries_1.0.data', help='cluster time series pickle \
    data from clustering method, used to parameterize time series method')
    parser.add_argument("-f", "--objective_function", choices=['bondwise', 'unified'], default='bondwise', help='type of objective\
    funtion used in scoring the BO and reference comparison. \'unified\' is traditional ROC and it \
    is found by calculating tpr/fpr for increasing window sizes and calculating the area under the curve of those points (plotted with tpr vs \
    fpr; \'bondwise\' is found similar to auc, but is scored on a bond-by-bond basis and is the fraction of reference transitions found)')
    parser.add_argument("-a", "--average_clusters", choices=[True, False], default=True, help='average the cluster bond order matrices \
    or take individual bond order matrices')
    parser.add_argument("-s", "--sigma_input", type=float, nargs="*", default=[35, 150.1, 1], help='accepts a single input for a single sigma \
    OR accepts 3 inputs to create a range: starting sigma, ending sigma, increment value. If both -s AND -t are provided a single input, \
    a single map point is analyzed. If 3 inputs are provided to -s or -t, a parameter map is created (possibly time consuming).')
    parser.add_argument("-t", "--threshold_input", type=float, nargs="*", default=[0.1, 1.51, 0.1], help='accepts a single input for \
    a single BO value OR accepts 3 inputs to create a range: starting BO, ending BO, increment value. If both -s AND -t are provided a single input, \
    a single map point is analyzed. If 3 inputs are provided to -s or -t, a parameter map is created (possibly time consuming).')
    parser.add_argument("-m", "--score_matrix", type=str, choices=['create', 'load'], default='load', help='create OR load the score matrix pickle file \
    for a parameter map using a range of sigma and threshold values')
    args = parser.parse_args()
        
    # create the sigma_list (smoothing parameter for low-pass filter)
    if len(args.sigma_input) == 1:
        sigma_list = np.array(args.sigma_input)
    elif len(args.sigma_input) == 3:
        sigma_list = np.arange(*args.sigma_input)
    else:
        raise ValueError('incorrect number of sigma inputs')

    # create the BO_threshold_list (BO or BO derivative threshold)
    if len(args.threshold_input) == 1:
        threshold_list = np.array(args.threshold_input)
    elif len(args.threshold_input) == 3:
        threshold_list = np.arange(*args.threshold_input)
    else:
        raise ValueError('incorrect number of threshold inputs')
    
    # load the reference data, default title is 'timeseries_1.0.data'
    cluster_time_series = pickle.load(open(args.reference_data, 'rb'))
    # use the Forcebalance Molecule class on the .xyz data from the MD simulation
    m = Molecule(args.coordinates)
    # elements list (in index order) from the forcebalance Molecule class
    elements = m.elem

    sampling_rate = 10**15
    TEST_scanner = BOTS_scanner(elements=elements, cluster_time_series=cluster_time_series, bond_order_list_name=args.raw_bond_order_list, opt_bond_order_list_name=args.opt_bond_order_list, coors_list_name=args.coordinates, sampling_rate=sampling_rate, average_clusters=args.average_clusters, sigma_list=sigma_list, threshold_list=threshold_list)
    if args.score_matrix == 'create':
        TEST_scanner.get_scores(args.objective_function)

    
    # analyze only a single point of the map (one sigma-threshold combination)
    if (len(args.sigma_input) == 1) and (len(args.threshold_input) == 1):
        sig = args.sigma_input
        thresh = args.threshold_input
        print('single sigma-threshold combination being analyzed')
        # inputs are lists, taking the first entry
        TEST_scanner.generate_all_plots(args.sigma_input[0], args.threshold_input[0], args.objective_function)
    # create the heat map for a given sigma and threshold range
    else:
        print('map being created for sigma and threshold range')
    
    #    sig = 40.0
    #    thresh = 0.7
    
    #    TEST_scanner.find_rxn_events(sig, thresh)
        TEST_scanner.make_heatmap(sigma_list, threshold_list)
    
    TEST_scanner.generate_output()

    
if __name__ == '__main__':
    main()


